#!/bin/bash
###############################################################################
# UTF-8
#
# НАЗНАЧЕНИЕ:  
#    -  Бекап qemu/kvm виртуалок
#    -  Подготовка каталога бекапов ВМ к синхронизации с хранилкой
#
# ЗАВИСИМОСТИ:
#    - bash 4.0+
#    - sudo qm 
#    - sudo vzdump 
#    - sudo pct
#    - sudo /bin/rm -f /var/run/vzdump.lock
#    - lzop
#    - chown -R backup /var/lib/vz/dump  # для юзера backup и каталога куда складываются дампы
#
# ИСПОЛЬЗОВАНИЕ:
#      vmbackup.sh "Список ВМ"   "Путь к каталогу с дампами ВМ"
#                  "Срок хранения бекапов локально, дней" 
#                  "Срок хранения бекапов на хранилке, дней"
#                  "режим провизинга"
#                  "дневной лимит для провизинга дампов, Gb"
#                  "резерв места для прогноза, Gb"
#       ,где:
#       "Список ВМ" в формате: 
#                  "vm_name_1 sync
#                   vm_name_1 nosync" ...
#                   sync - означает передавать бекап в удаленное хранилище
#                   любой другой параметр - не передавать.
#       "Срок хранения бекапов локально":
#                   удалять локальные бекапы возрастом более ... часов
#       "Срок хранения бекапов на хранилке":
#                   хранить бекапы ВМ в удаленном хранилище с разницей 
#                   не менее ... дней от последнего локального бекапа
#       "режим провизинга":  
#                   "provide" включен, иначе - выключен.
#       "дневной лимит для провизинга дампов":
#                    Ограничить ежедневый трафик дампов на хранилку
#       "резерв места для прогноза":
#                    Учитывать в прогнозе оставшегося места 
#                    перед выполнением бекапа
#
# ЛОГИКА БЕКАПЕРА:
#    1. Спрогнозировать свободное место после выполнения бекапа на основании 
#        последнего бекапа (если есть) плюс запас ${fs_reserved_mb}. 
#        Если прогноз покажет, что места не останется, выйти с ошибкой.
#    2. Выполнить бекап. Если ошибка, выйти прибив обрубки недобекапов и *tmp
#    3. Удалить старые бекапы > ${keep_hwrs_local}
#
# ЛОГИКА ПРОВИЗИНГА:
#    1. Собирается список бекапов с подошедшим сроком передачи в хранилку 
#        (позднее $keep_days_remote относительно последнего локального бекапа)
#    2. Список сортируется по убыванию срока. 
#        (Вверху самые тухлые или впервые линкуемые)
#    3. Устанавливается в 0 Mbytes счетчик дневого лимита.
#    4. Линкуется первый по списку бекап.
#    5. Суммируется его объем в счетчик.
#    6. Берется следующий по списку бекап.
#    7. Если его вес суммированный со счетчиком не превысит лимита 
#        ${sync_daily_limit_mb}, бекап хардлинкуется в sync-каталог,
#        после чего кол-во бекапов в нем приводится к ${keep_files_remote}
#        начиная с самых тухлых.
#    8. Goto 6.
#
# БАГОФИЧИ
#     - Проверка не делается на предмет выполняется или нет в данный момент 
#        бекап ВМ. Файл бекапа будет слинкован как есть. 
#        Если файл недосинкается сегодня, досинкается завтра.
#     - Счетчик дневного лимита линкуемых бекапов считается только в рамках 
#        текущей сессии и его состояние нигде не сохраняется. Поэтому правильнее 
#        запускать скрипт в этом режиме не чаще одного раза в день.
###############################################################################

#-----------------------------------------------------------------------------+
# Это служебный кусок для режима запуска скрипта из самого себя как hook-script
#  https://github.com/proxmox/pve-manager/blob/master/vzdump-hook-script.pl
#  Изначально предназначен для удаления треша с владельцем root после неудачных
#  запусков. 
#  Можно пользовать в иных целях: хуки для разных стадий vzdump - ссылка выше
#  Внимание: скрипт будет работать от root
# $1,shifted: -vzscript
# $1: ${vm_dump_dir}        /var/lib/vz/dump
# $2: ${vm_dump_pfx}    vzdump-qemu
# $3: $i                my-cewl-vm
# $4  ${vm[$i]}         666
# $5: ${timestamp}      09042015_1714
# $6: "stage"           job-abort
#-----------------------------------------------------------------------------+
[ "$1" = "-vzscript" ] && {
  shift;
  [ $# -lt 6 ] && { echo "[ERROR] -vzscript lack of params: $@"; exit 1;}
  vm_dump_dir=$1; vm_dump_pfx=$2; VMNAME=$3; VMID=$4; timestamp=$5; dump_stage=$6;
  echo [STAGE] $dump_stage

  case $dump_stage in
        job-start)
            find ${vm_dump_dir} -maxdepth 1 -mmin +1440 -type d -iname \*.tmp \
               | xargs -r rm -vrf
           ;;
        *abort)
           echo "[ERROR] Removing all my unfinished and temp. shit...";
           rm -rvf ${vm_dump_dir}/${vm_dump_pfx}-{${VMID},${VMNAME}}-*${timestamp}.*;
           ;;
  esac
exit;
}



###############################################################################
#  GLOBALS    
###############################################################################
vm_list="$1"                # список ВМ пар
vm_dump_dir="$2"            # каталог с дампами
keep_hwrs_local=$3          # срок хранения бекапов локально, часов
keep_days_remote=$4         # срок хранения бекапов на хранилке, дней
sync_provide_mode="$5"      # режим провизинга (со скипом vzdump)

#  Лимит синко-траффика в день, Mb. По дефолту, 10Gb
sync_daily_limit_mb=$(( ${6:-10} << 10 ))

# сколько должно еще остаться места после бекапа, Mb. По дефолту, 2Gb
fs_reserved_mb=$(( ${7:-2} << 10 ))

sync_path=.rsync            # подкаталог каталог с бекапами для синка на хранилку
vm_dump_pfx=vzdump-qemu     # префикс дампов ВМ
keep_files_remote=1	       # кол-во хранимых бекапов одной ВМ на хранилке
timestamp=$(date +"%Y_%m_%d-%H_%M_%S")  # пример: +"%d%m%Y_%H%M" 14042015_1331

vzdump="sudo /usr/bin/vzdump"
qm="sudo /usr/sbin/qm"
pct="sudo /usr/sbin/pct"
lzop=/usr/bin/lzop


#-----------------------------------------------------------------------------
#  статус-флаг, счетчик лимита траффика для провизинга
#  он же определен в скрипте rsync
#  удаляется после прогона rsync
#-----------------------------------------------------------------------------
mb_provision_remain_fileflag=${vm_dump_dir}/${sync_path}/.vm_mb_per_run.~


# ----------------
# Базовые проверки
# ----------------

# vzdump уже запущен

ps axw | grep /usr/bin/vzdump | grep -v grep && {
    echo "[ERROR] vzdump is already running. Exiting"
    exit 1
}

# Если не запущен, то потрем лок если остался с прошлого раза
sudo rm -f /var/run/vzdump.lock

#  минимальное кол-во агрументов
[ $# -lt 6 ] && 
{  echo "[ERROR] main script lack of params: $@"; exit 1;}


# $0 не всегда работает, если скрипт пускался с относит.путем
#    сохраним полный путь для cd/pushd и т.п.
[ "${0:0:1}" = "/" ] && my_full_path=$0 || my_full_path=$PWD/$(echo $0)

###############################################################################
#  FUNCTIONS 
###############################################################################


#------------------------------------------------------------------------------
#  out:  STDOUT: Указанный символ заданное кол-во раз
#   in:     $1: Символ
#           $2: Кол-во раз
#         [$3]: -n : без ENTER на конце
#------------------------------------------------------------------------------
seq_sym(){
  [ $# -lt 2 ] && echo "ERROR: $FUNCNAME(): lack of params: $*" && exit 1

  # удалить цифры из потока или еще до кучи ENTER если есть '-n'
  [ "$3" = "-n" ] && rm_set="[0-9]\n" || rm_set="[0-9]"

  seq --separator="$1" $(( $2+1 )) | tr --delete ${rm_set}
}

#------------------------------------------------------------------------------
#  out:  STDOUT: размер файла в байтах. Или 0, если файл недоступен/нет
#   in:     $1: имя файла
#           $2: [k|m|g]. По дефолту цифра в байтах
#------------------------------------------------------------------------------
print_file_size(){
   [ -f "$1" ] || { echo 0; exit; }
   case "$2" in
        [kK]*)
             shift_bits=10
        ;;
        [mM]*)
             shift_bits=20
        ;;
        [gG]*)
             shift_bits=30
        ;;
        *)
             shift_bits=0
        ;;
   esac
   echo $(( $(wc --bytes $1 | cut --delimiter=" " --fields=1) >> ${shift_bits} ))   
}

#------------------------------------------------------------------------------
#  out: STDOUT: свободный объем файловой системы в Kb
#   in:     $1: каталог файловой системы
#           $2: [m|g]. По дефолту цифра в Kb
#------------------------------------------------------------------------------
print_fs_free_size(){
   [ -d "$1" ] || { echo 0; exit; }
   case "$2" in
        [mM]*)
             shift_bits=10
        ;;
        [gG]*)
             shift_bits=20
        ;;
        *)
             shift_bits=0
        ;;
   esac
   echo $(( $(df --portability  --block-size=1K $1 \
            | awk 'NR>1 {print $4}') >> ${shift_bits} ))
}


#-----------------------------------------------------------------------------
# Инициировать ассоциативные массивы в формате:
#-----------------------------------------------------------------------------
declare -A vm; declare -A vmbak

#-----------------------------------------------------------------------------
# Загрузить в массив 'vmbak' пары ВМ из параметра женкинса. 
# Отфильтровать все пустые и закомменченные строчки
# Если он пустой (все ВМ закомменчены), выйти
#   аналогично операции vmbak[bdc]="sync"
#-----------------------------------------------------------------------------
eval vmbak=($(\
      echo "$vm_list" \
         |egrep --invert-match "(^#)|(^$)" \
             |while read i; do
                   set -- $i;
                   echo -n "[$1]=$2 ";
              done
     ))

[ ${#vmbak[@]} -eq 0 ] && { echo "[INFO] empty VM list. exiting..."; exit 0; };

#-----------------------------------------------------------------------------
# Загрузить в массив 'vm' актуальный список ВМ
#  аналогично операции: $vm[bdc]=102
#-----------------------------------------------------------------------------
eval vm=($(\
          (${qm} list | sed -n '1!p'; ${pct} list | awk 'NR>1 {print $1,$3}') \
              |while read i; do
                     set -- $i;
                     echo -n "[$2]=$1 ";
               done
     ))
#-----------------------------------------------------------------------------
# Далее массивы использовать можно так:
#	echo VMID: ${vm[zabbix]}
#	echo values: ${vmbak[*]}
#	echo indexes: ${!vmbak[*]}
#-----------------------------------------------------------------------------

#-----------------------------------------------------------------------------
# Проверить, что все сконфигуренные в женкинсе для бекапа ВМ существуют
# В grep скармливается список ВМ переданных параметром в качестве паттерна
# к актуальному списку существующих ВМ. 
# Если что-то из "паттерна" не нашлось - значит ВМ нет/переименована
# все имена ВМ РЕГИСТРОЗАВИСИМЫ!
#-----------------------------------------------------------------------------
echo "[INFO] checking for unknown VMs..."
echo ${!vmbak[@]} | tr " " "\n" \
   |egrep --invert-match --regexp="$(echo ${!vm[@]} | tr ' ' '\n')" && 
          { echo "[ERROR] found missing VMs. Exiting."; exit 1; };


###############################################################################
# Режим генерации дампов ВМ
#  пропустить, если включен режим провизинга
###############################################################################
  unset no_dump_err
[ "${sync_provide_mode}" = "provide" ] || {
  pushd ${vm_dump_dir} > /dev/null
  for i in ${!vmbak[@]}; do
  {
    sync
    fs_free_mb=$(( $(print_fs_free_size . Mb) - fs_reserved_mb ))  
    latest_bk_size_mb=$(print_file_size \
                      $(ls -1t ${vm_dump_pfx}-$i-*.lzo 2>/dev/null | head -1 ) M)
    echo "[INFO] $(seq_sym '*' 72)"
    echo "[INFO] * $i (${vm[$i]}) ,${vmbak[$i]}"
    echo "[INFO] $(seq_sym '*' 72)"
    echo "[INFO] Telepathed: ${latest_bk_size_mb} Mb, avail: ${fs_free_mb} Mb"

    [ ${latest_bk_size_mb} -gt ${fs_free_mb} ] && 
     {
        echo "[ERROR] Not enough space to store the backup. Skipping...";
        no_dump_err+="[ERROR] space prognosis failed for $i, skipped\n";
        continue;
     }


    bkname=${vm_dump_pfx}-$i-${vm[$i]}-${timestamp}.vma.lzo

    ${vzdump} ${vm[$i]} --mode snapshot --lockwait 15 --stdout -script\
       "/bin/bash $my_full_path -vzscript ${vm_dump_dir} ${vm_dump_pfx} $i ${vm[$i]} ${timestamp}"\
           |${lzop} -c > ${bkname}

    [ $? -ne 0 -o ${PIPESTATUS[0]} -ne 0 ] && 
     {
       echo "[ERROR] backup interrupted";
       rm --recursive --verbose --force ${bkname};
       no_dump_err+="[ERROR] backup failed for $i, skipped\n";
       continue;     
    };
  # ----------------------------------------------------------------------------
  #    если ошибок не было, удалить старые дампы только в каталоге с дампами
  #    использовать для кол-ва дней mmin. (ctime - учитывает только целый день)
  # ----------------------------------------------------------------------------
    echo "[INFO] Removing $i backups older then ${keep_hwrs_local} hwrs:"
    find . -maxdepth 1 -mmin +$(( keep_hwrs_local * 60 )) -type f \
         \( -name "${vm_dump_pfx}-${i}-*" -o -name "${vm_dump_pfx}-${vm[$i]}-*" \)\
         -print -delete;
  };done
}



###############################################################################
# Режим предоставления дампов для синхронизации с хранилкой
###############################################################################
echo "
********************************************************************************
*   provisioning VM backups for remote sync
********************************************************************************"

[ -d ${vm_dump_dir}/${sync_path} ] || { 
	mkdir -vp ${vm_dump_dir}/${sync_path} || exit $?
}

# Если флага нет инициировать его
[ -r ${mb_provision_remain_fileflag} ] ||
       echo -n ${sync_daily_limit_mb} > ${mb_provision_remain_fileflag}

pushd ${vm_dump_dir}
#------------------------------------------------------------------------------
#  Сгенерить в STDOUT таблицу бекапов (для sync), сортированными по тухлости 
#                                 тухлость 9999 - бекап ни разу не синкался
#   в виде: 
#   (заголовки здесь чисто для удобства восприятия)
#+--------------+-------------+------------+-----------------------------+
#   имя ВМ      | Тухлость    |            |                             |
#               | засинканного| Вес_бекапа | Имя локального бекап-файла  |
#               | бекапа,дней | Mb         |                             |
#+--------------+-------------+------------+-----------------------------+ 
#   my-cewl-vm1 | 9999        | 20865      |  ./vzdump-qemu-myvm1-xxx.lzo|
#   my-cewl-vm2 | 10          | 208651     |  ./vzdump-qemu-myvm2-xxx.lzo|
#   my-cewl-vm3 | 2           | 8651       |  ./vzdump-qemu-myvm3-xxx.lzo|
#---------------+-------------+------------+-----------------------------+
for i in ${!vmbak[@]}; do 
{
  [ "${vmbak[$i]}" = "sync" ] && 
   {
      vm_dump_local=$(ls -1t ${vm_dump_pfx}-$i-*.lzo 2>/dev/null | head -1 );
      [ -f "$vm_dump_local" ] || continue;

      vm_dump_sync=$(ls -1t ${sync_path}/${vm_dump_pfx}-$i-*.lzo 2>/dev/null \
                    | head -1 );
#------------------------------------------------------------------------------
#        если есть бекап в sync-каталоге, посчитать его тухлость в днях 
#        относительно последнего актуального бекапа.
#        если бекапа нет в sync-каталоге, "назначить" тухлость 9999 дней
#------------------------------------------------------------------------------
      [ -f "$vm_dump_sync" ] &&
        {
         vm_dumps_days_diff=$(echo \
         $(( 
             ( $(stat --format=%Y ${vm_dump_local})
             - $(stat --format=%Y ${vm_dump_sync}) 
             )/60/60/24
          )) )
      } || {
         vm_dumps_days_diff=9999
      }
      [  ${vm_dumps_days_diff} -gt ${keep_days_remote} ] && 
           echo $i \
                ${vm_dumps_days_diff} \
                $(print_file_size ${vm_dump_local} Mb) \
                ${vm_dump_local}
  };
#------------------------------------------------------------------------------
#   Сгенеренная таблица скармливается через пайп в цикл while в сообразные $n:
#   $1 (vm name)  $2 (date diff)  $3 (size, Mb)  $4 (bk file name)
#   my-cewl-vm    10              20865          ./vzdump-qemu-myvm-xxx.lzo
#------------------------------------------------------------------------------
};done \
     |sort --general-numeric-sort --key=2 --reverse \
         |while read i; do 
            {
              # $1:vm_name  $2:date_diff  $3:size_Mb  $4:dump_name
               set -- $i;

              #----------------------------------------------------------------
              #  Прочитать из файл-флага доступный лимит.
              #  если уже провизили что-то И прогноз остатка места зафейлился,
              #  пропустить дамп и запытать следующий.
              #  если это первый в очереди дамп, по-любому слинковать его.
              #----------------------------------------------------------------

               read sync_remaining_mb < ${mb_provision_remain_fileflag}
               [ $sync_remaining_mb -ne $sync_daily_limit_mb -a \
             $(( sync_remaining_mb - $3 )) -lt 0 ] && 
               {
                  echo "[SKIP/$3] $1 is above the remaining daily limit. skipped";
                  continue;
               };
              #  дамп влез в дневной лимит. Слинковать и привести 
              #  кол-во sync-дампов ВМ в соответствие с $keep_files_remote
              #  сохранить статус лимита в файл-флаге
              ln --force $4 ${sync_path}/ || exit $?
              ls -t1 ${sync_path}/${vm_dump_pfx}-$1-*.lzo \
               | tail --lines=+$(( keep_files_remote + 1 )) \
                    | xargs --no-run-if-empty rm
              
              : $(( sync_remaining_mb -= $3 ));
              echo -n $sync_remaining_mb > ${mb_provision_remain_fileflag};
              echo "[LINKED] $1 ($3 Mb). Avail: $sync_remaining_mb Mb to hit runlimit"
            }; done
echo [INFO] all done for today!

[ "${no_dump_err}" ] &&  echo -e "\n\n${no_dump_err}" && exit 1;
exit 0